# C-005 : Intent → Context Map
(Layer Boundary & Dependency Governance)

---

## 1. Intent Summary (의도 요약)

본 아키텍처의 핵심 의도는 **"도메인 로직(Core)의 순수성 보존"**이다.
기술 환경(Framework, DB, UI)은 시간이 지남에 따라 변하지만, 비즈니스의 핵심 규칙(Core)은 그보다 오래 지속된다.
따라서 우리는 변화가 잦은 것(Adapter)으로부터 변화하지 않아야 하는 것(Core)을 보호하기 위해 강력한 경계(Boundary)를 세운다.

---

## 2. 의존성 흐름의 의도 (Intent of Dependency Flow)

### 2.1 왜 Core는 아무것도 의존하지 않는가?
- **의도**: 외부 환경의 변화에 Core가 영향을 받지 않게 하기 위함이다.
- **설명**: 만약 Core가 특정 DB 라이브러리를 import 한다면, DB를 교체할 때 Core 코드도 수정해야 한다. 이는 비즈니스 로직의 안정성을 해친다. Core는 오직 자기 자신의 언어적 특성(Language Spec)에만 의존해야 한다.

### 2.2 왜 Adapter는 Core에 의존하는가?
- **의도**: 외부 기술을 사용하여 비즈니스 규칙을 수행하기 위함이다.
- **설명**: Adapter는 Core가 정의한 "무엇을 해야 하는가(Interface)"를 "어떻게 할 것인가(Implementation)"로 번역하는 역할을 한다. 따라서 Adapter는 Core의 명세(Contract)를 알고 있어야 한다.

### 2.3 왜 Interface(Port)는 Core에 있는가?
- **의도**: 주도권(Control)을 Core가 가지기 위함이다.
- **설명**: "데이터를 저장한다"는 행위가 필요할 때, Core는 "저장소 인터페이스"를 정의하여 요구사항을 명시한다. Adapter는 이 요구사항을 맞추기 위해 구현할 뿐, Core가 Adapter의 구현 방식에 맞추지 않는다. 이것이 의존성 역전(DIP)의 핵심이다.

---

## 3. Sandbox의 역할과 한계

### 3.1 역할: 혁신의 놀이터
- Sandbox는 엄격한 아키텍처 규칙을 잠시 유보하고, 빠르게 아이디어를 검증하거나 복잡한 기능을 통합해볼 수 있는 공간이다. 여기서 개발자는 구조보다는 기능 구현에 집중할 수 있다.

### 3.2 한계: 영구 거주 불가
- Sandbox의 코드는 "완성품"이 아니다. 그것이 정식 기능으로 채택되려면 반드시 **"정제(Refining)"** 과정을 거쳐 Core와 Adapter로 분리되어야 한다. Sandbox 코드가 그대로 Production의 핵심 로직으로 사용되는 것은 아키텍처의 부패를 의미한다.

---

## 4. 사람과 AI를 위한 가이드

### 개발자에게
- "이 코드를 Core에 넣어도 될까?"라고 고민된다면, `import` 문을 보라. 외부 패키지 이름이 보인다면 그것은 Core가 아니다.
- Core를 수정해야 하는 이유는 오직 "비즈니스 규칙의 변경" 때문이어야 한다. "DB 업데이트" 때문에 Core를 건드리지 마라.

### AI 에이전트에게
- 코드 생성 요청을 받았을 때, 파일의 경로(`src/core/...`)를 먼저 확인하라.
- Core 경로라면, 어떠한 외부 라이브러리 사용 제안도 거절해야 한다. 오직 순수한 언어 문법과 내부 모듈만으로 해결책을 제시하라.
- 사용자가 구조를 위반하는 코드를 요청하면, C-005의 의도를 근거로 수정을 제안해야 한다.
